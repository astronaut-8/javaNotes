# **6.24 客户端一面**

**自我介绍** 

wc太紧张了，从这里开始卡壳



**介绍mini-spring项目(思路不够清楚，得做完整复盘)**



**对aop的理解**

- aop是一种编程范式，横向抽取关注点与核心业务隔离，**避免代码冗余**

- 解偶核心业务和辅助功能，提高代码可维护性和复用性
- Spring通过动态代理实现aop JDK CGLIB
- 核心组件 - JoinPoint Pointcut Advice Aspect
- 应用场景 - 日志，事物，性能检测，权限校验



Spring AOP是运行时织入，AspectJ是编译是织入 

- spring aop 运行时动态生成代理对象 aspectJ编译时，类加载时织入
- spring aop 使用JDK/CGLIB aspectJ 直接修改字节码
- spring aop只支持方法级别的拦截 aspectJ 支持字段，构造器，方法，异常的织入
- spring aop每次方法调用都会通过代理对象，存在性能开销 aspectJ 字节码直接修改，运行没有额外开销
- spring aop使用简单适合简单场景 aspectJ功能全面，适合复杂场景

**Aop除了用动态代理还可以用什么实现？**

**动态代理和静态代理**

- 动态代理 - 运行时织入 - jdk/cglib - 方法级别 
- 静态代理 - 编译/类加载时织入 - AspectJ(Java生态最完整的aop实现，有动态有静态，一般用静态) - 粒度细

**动态代理有什么用 具体应用场景**

- 日志，事物，性能检测，权限校验
- Dubbo 框架对于远程方法的调用只需要填入地址端口，使用aop完成网络通信的细节

**单例对象怎么创建**

- 饿汉式 - 类加载时直接创建 - static final
- 懒汉式 - double check
- 懒汉式 - 声明成静态内部类的static final 字段 只有外部类被访问的时候才初始化
- 枚举类 - 反序列化安全(对于非枚举类 反序列化会绕过构造函数限制，直接生成新对象) - 也可以防御反射



- 重写 单例对象的readResolve方法，反序列化的时候调用这个方法，直接返回 实例

- ```java
  // 反序列化处理
      private Object readResolve() {
          return SingletonHolder.INSTANCE;
      }
  ```

- 反射可以获取类的构造器，再造出一个实例来 在构造函数中去判断单例是否已经存在，因为他也要通过构造方法去生成

- ```java
  private DefendedSingleton() {
          // 关键防护：防止反射创建新实例
          if (instance != null) {
              throw new IllegalStateException("单例已存在，禁止通过反射创建！");
          }
          
          // 正常初始化逻辑
          System.out.println("初始化单例...");
      }
  ```

**volatile 实现可见性，有序性的原理**

可见性

- JVM层面 - 对volatile的写操作生成一个lock前缀的汇编指令 - 写操作强制把变量刷新到主存，读操作强制从主存中读取
- 硬件层面 - 数据写回主存 - 使用mesi协议让其他处理器缓存行失效

有序性

内存屏障

**volatile int i   i++ 这一步用什么去做了保证**

首先有线程安全问题，volatile无法保证原子性问题

**介绍cas**

compare-and-swap/set



- cpu原子指令
- JVM - Unsafe类
- JUC下包提供cas方法，基于Unsafe实现

应用

- 原子类
- 用于ConcurrentHashMap
- 乐观锁



- 无锁，原子，线程不阻塞
- ABA问题，竞争冲突性能下降(cas大量失败)，只能控制单个变量

**volatile int i    AtomicInteger  LongAdder 三者比较**

使用场景分析

第一个不能保证原子性，需要额外同步机制保证



第二个 高频读，低频写



第三个高并发读写

**hashMap 冲突解决具体**

常规

**网络一个啥问题不记得了因为我不会**



**get post请求区别**

目标 参数长度位置 安全性 使用场景 幂等性 缓存支持 编码方式

**登陆接口应该用get 还是 post  post怎么保证body安全传输**

post

提高post安全性的方式

- 使用https加密传输 - 通过数据加密和身份验证，保证完整性

- 敏感参数加密传输，不传明文

- 防止CSRF - sameSite - 验证Origin - CSRF Token(后端在用户登陆后分配一个token，前端隐藏存储，每次请求放到请求头一同发送，后端验证token)

  

可能还有但没什么印象了





手撕 - **Double check**手写 问了为什么要double (双重判断) 为什么要使用volatile(分析指令重排问题)



**链表重排序**，给定一个有序的链表比如1-2-2-3-4-4 有元素重复 就让这个元素全部消失 变为1-3 直接出题，不是lc

面试卡壳了，写了一坨屎直接摆在那里了

double-check写的不错，分析也都说出来了，可能让面试官给我了一点宽容

他给我说了一个简易的思路 我恳求再给我一个机会，他说那直接把他的思路实现一下，谢天谢地 我两三分钟就写出来了，给面试官🧎了，感谢不杀之恩！

# 6.26客户端二面

**泛型 - 是什么，有哪些需要注意的，基础的原理是什么，为什么要有泛型这个东西**



概念和作用

泛型是一种编程机制，允许类，接口，方法在定义的时候使用类型参数，这些参数在实际使用的时候会被具体的类型所替换

泛型的核心思想是把类型参数化，把类型当作参数一样传递，使得代码可以处理多种数据类型，而不用重复编码

- 类型安全 - 泛型在编译的时候进行限定的类型检查，确保类型的一致性，减少运行时的类型错误，使用泛型集合，可以避免将错误的类型的对象加入集合
- 不需要类型转换 - 使用泛型，编译器只要具体类型，不需要手动进行类型转换(从集合中取元素)
- 代码复用 - 同一个逻辑可以适配多种不同的数据类型



基本原理

- 类型擦除 - 

Java C#等语言实现泛型的机制，代码编译的时候将反省擦除，替换为他们的边界类型(Java中为Object)，具体使用的时候，编译器会插入类型转换的代码

如果有边界，擦除为第一个边界类型 - <T extends Number> 擦除结果为Number

- 类型擦除可以保证泛型代码和非泛型代码的兼容性
- 限制了运行时获取泛型信息的能力



- 具体化类型

Kotlin Swift 语言泛型信息在运行时保留，使得可以在运行的时候获取泛型参数类型



使用泛型的意义

- 在编译时候类型检查，减少运行时错误
- 简化代码，可以省去类型转换的步骤(List<Object> 中取对象)
- 促进框架和库的开发，更加容易开发通用库



注意事项

- 类型擦除，运行时无法直接获取泛型参数的具体类型
- 泛型类型不能实例化，不能通过它创造实例
- 不能创建具体泛型类型的数组
- 注意通配符的使用 ? extends T  ? super T
- 性能问题 - 不正确的使用会造成性能开销(频繁装箱和拆箱) - List<Integer> 每次读取int数字，都是装拆箱的过程

**你听过类型差除这个概念吗**

泛型的基本原理之一

**有没有看过泛型字节码编译出来是什么样子**

- 首先类型擦除
- 其次，对于读写命令，加入 自动类型转换的字节码指令

**你对 java checkedException  uncheckedException有什么看法**

- 一个运行时，一个编译时
- Error程序无法处理(超出程序处理能力)，通常不应该捕获
- 对于check，强制开发者考虑异常情况，保证代码健壮性
- 分离错误责任 - Check的错误可能是外部因素的，Unckeck的往往开发者是可控的比如数组越界，应该去修改程序的逻辑
- checkedException 不用try catch可以throws，这是对方法签名的影响
- 子类重写的方法不能抛出比父类更大的异常

**简单介绍Java类加载的各个阶段**



**双亲委派模型**



**做两个项目遇到了哪些挑战性的事情**

原码和新技术栈

**算法 - lc.142 环形链表2   +   LRU(字节祖传算法)**



**问我写博客的初衷是什么**

记录复杂原码，因为我看完就忘

**你印象深刻的一些类或者模块的原码**

介绍了Spring AOP的具体实现

# 7.1客户端三面