# 计算机网络概述

## 1.1 什么是Internet，协议

   **网络由节点和边构成**，和形状没关系

**节点**

- **主机节点 - 手机电脑，web服务器**    host  endSystem

- **数据交换节点 - 路由器 交换机 （既不是端也不是源）**switch route 。。。

**边 - 通信链路**

- **接入网链路，主机连接到互联网的链路**
- **主干链路 ， 路由器之间的链路**





带宽 - 传输速率 bps - 每秒钟传输的位的数量



互联网 是许多网络的互联



<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-25%2009.50.01.png" alt="截屏2024-09-25 09.50.01" style="zoom: 50%;" />

**协议**

Internet中所有的通信行为都受协议制约

**协议定义了在两个或者多个通信实体之间交换的报文格式和次序，以及在报文传输或接收其他事物方面所采取的动作**

<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-25%2009.59.05.png" alt="截屏2024-09-25 09.59.05" style="zoom:50%;" />

**分布式应用，为分布式应用提供基础设施 - 网络**

 

##  N1.2 网络边缘

<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-25%2020.11.32.png" alt="截屏2024-09-25 20.11.32" style="zoom:50%;" />

**边缘接入核心**

**链路需要被复用**

**网络核心 - 数据交换**

<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-25%2020.13.28.png" alt="截屏2024-09-25 20.13.28" style="zoom:50%;" />



<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-25%2020.18.20.png" alt="截屏2024-09-25 20.18.20" style="zoom:50%;" />

**面向连接**

<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-25%2020.25.39.png" alt="截屏2024-09-25 20.25.39" style="zoom:50%;" />

**采用基础设施的无连接服务** 

<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-25%2020.35.49.png" alt="截屏2024-09-25 20.35.49" style="zoom:50%;" />

## 1.3 网络核心

<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-25%2020.39.57.png" alt="截屏2024-09-25 20.39.57" style="zoom:50%;" />

 



### 电路交换

信令系统 建立独享线路 性能被保障 

<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-25%2020.41.53.png" alt="截屏2024-09-25 20.41.53" style="zoom:50%;" />

电路交换 为呼叫 预留 端到端的资源

- 链路带宽 交换能力
- 专用资源，不共享
- 保证性能
- 要求建立呼叫连接

**分片**

 <img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-25%2020.47.50.png" alt="截屏2024-09-25 20.47.50" style="zoom:50%;" />

<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-25%2020.49.02.png" alt="截屏2024-09-25 20.49.02" style="zoom:50%;" />

波分 - 光纤 光通讯的方式

将光的可用波段 分成若干个小piece



**计算机之间不适合使用电路交换的原因**

- 建立连接的时间长
- 计算机之间通信突发性强，使用线路交换，浪费的片多 （这个呼叫没有数据传递，其所占据的片也不能够被别的呼叫使用）
- 可靠性不高（节点交换机需要不断维护大量的piece之间的线路）



### 分组交换

<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-25%2021.00.54.png" alt="截屏2024-09-25 21.00.54" style="zoom:50%;" />

以分组(packet) 为单位在每一个交换节点中存储再转发

存储转发的意义

​	假设a - b 经过一个交换节点，如果a的数据经过交换节点不存储直接转发，那么一整条线路都是处于使用状态，也就是说在a向交换节点发送数据的过程中，交换节点无法再处理到b的其他数据(这条链路无法被其他的主机对所使用，失去的网络的复用 共享性 ) 等于变成了a的独享线路

<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-25%2021.09.13.png" alt="截屏2024-09-25 21.09.13" style="zoom:50%;" />





<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-25%2021.11.55.png" alt="截屏2024-09-25 21.11.55" style="zoom:50%;" />

**它根据各个数据流或会话的实际需求来分配通信链路的带宽，而不是事先为每个数据流分配固定的带宽。这种技术能够更有效地利用通信链路的带宽资源，特别是在数据流量具有突发性和不均匀性的情况下。**

<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-25%2021.16.24.png" alt="截屏2024-09-25 21.16.24" style="zoom:50%;" />

分组交换

适合突发式的数据传输 - 资源共享(交换节点的存储转发)  简单 不必建立时间

过度使用会造成网络拥堵，分组延迟和丢失

对可靠数据传输需要协议来约束 拥塞控制



<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-25%2021.28.36.png" alt="截屏2024-09-25 21.28.36" style="zoom:50%;" />

路由器不维护主机和主机之间的状态

<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-25%2021.30.28.png" alt="截屏2024-09-25 21.30.28" style="zoom:50%;" />

靠信令建立 

<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-25%2021.32.22.png" alt="截屏2024-09-25 21.32.22" style="zoom:50%;" />



**数据报和虚电路是分组交换的两个关键传输模式**

**数据报**

- 无连接，发送方和接收方在传输数据的时候不用建立专门的连接(**传输效率高**)
- 每个数据报独立在网络中传播，**没有固定的顺序和关系**
- 每个数据报**包含完整的地址信息**，在网络中能够转发到正确的目的地
- 数据报在传输的时候可能选择不同的路径，因此不同数据报**可能会以不用顺序到达接收方**
- **灵活性强**，能够**适应网络拓扑变化**
- 适用于传输**对实时性要求不高**，允许一定**丢包**的数据

- 数据可能**乱序到达**，需要接收方进行排序处理
- **无法保证数据的可靠传输**，可能出现数据丢失重复

**虚电路**

- 面向连接，传输数据之前， 发送方和接收方需要**建立逻辑上的连接**
- 虚电路建立后，通信双方根据逻辑连接**依次发送分组**，接收方分组顺序和发送方**顺序一致**
- **可以是临时连接也可以是永久**
- 每个分组除了数据还有**虚电路标示号** 用于识别分组所属的虚电路
- 保证数据的**顺序传输和可靠性传输**
- 适用于传输对**实时性**和**可靠性高**的数据
- 需要建立连接，**传输效率低**
- **维护管理复杂**

### 关键功能

<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-25%2021.14.17.png" alt="截屏2024-09-25 21.14.17" style="zoom:50%;" />



## 1.4 接入网和物理媒体

**怎样将端系统和边缘路由器连接**

- 住宅接入网络
- 单位接入网络
- 无线接入网络

**attention**

- 接入网络的带宽 - bps (bits per second)
- 共享还是专用

### 住宅接入- modem

将计算机等数字设备产生的数字信号转换为适合在通信线路上传输的模拟信号（调制过程），以及在接收端将模拟信号转换回数字信号（解调过程）

**将上网数据调制加载音频信号上，在电话线上传输，在局端将其中的数据解调出来**

- 调频
- 调幅
- 调相位
- 综合调制

**拨号调制解调器**

- 56Kbps的速率直接接入路由器 （通常更低）
- 不能同时上网和打电话，不能总是在线



本来电话线 用来传输音频信号，为用作网络数据交换 使用调制解调器 通过各种调制 使得声音信号和网络信号产生差异 使得两种信号可以被区别出来

### 接入网 - DSL

数字用户线路

**DSL技术利用频分复用技术，将电话线中的低频段用于传输传统电话业务，而高频段则用于传输宽带数据**

ADSL（Asymmetric Digital Subscriber Line，非对称数字用户线）

**ADSL的下行带宽（即从网络到用户的方向）远大于上行带宽（即从用户到网络的方向），这种非对称特性非常适合互联网应用，因为用户下载的数据量通常远大于上传的数据量。**







DSL接入网主要包括以下几个部分：

1. **DSL调制解调器**：安装在用户家中，用于将计算机发出的数字信号调制为模拟信号，以便在电话线上传输。同时，它还能将接收到的模拟信号解调为数字信号，供计算机处理。
2. **DSLAM（Digital Subscriber Line Access Multiplexer，数字用户线接入复用器）**：安装在电信运营商的机房中，负责将多个用户的DSL信号进行汇聚和复用，然后通过高速光纤或铜缆连接到互联网骨干网。
3. **用户线**：即现有的电话用户线，用于传输DSL信号。这条线路同时承载着电话业务和宽带数据业务，通过频分复用技术实现两者之间的互不干扰。



### 接入网 - 线缆网络

有线电视信号线缆双向改造（原有的线路只能传 下行 - 从网络到用户）

FDM - 在不同频段传输不同信道的数据 数字电视和上网数据



<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-26%2015.40.05.png" alt="截屏2024-09-26 15.40.05" style="zoom:50%;" />

这是共享的

用户共享上行带宽

### 无线接入网络

<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-26%2015.44.10.png" alt="截屏2024-09-26 15.44.10" style="zoom:50%;" />

### 物理媒体

<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-26%2015.46.34.png" alt="截屏2024-09-26 15.46.34" style="zoom:50%;" />

<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-26%2015.47.55.png" alt="截屏2024-09-26 15.47.55" style="zoom:67%;" />

<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-26%2015.51.52.png" alt="截屏2024-09-26 15.51.52" style="zoom:50%;" />



## 1.5 Internet结构和ISP

  ![截屏2024-09-26 15.59.46](https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-26%2015.59.46.png)



<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-26%2016.02.04.png" alt="截屏2024-09-26 16.02.04" style="zoom:50%;" />

<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-26%2016.03.36.png" alt="截屏2024-09-26 16.03.36" style="zoom:50%;" />



 <img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-26%2016.10.02.png" alt="截屏2024-09-26 16.10.02" style="zoom:50%;" />

运营商 用专线 把自己的ixp连接起来

![截屏2024-09-26 16.11.39](https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-26%2016.11.39.png)



<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-26%2016.13.26.png" alt="截屏2024-09-26 16.13.26" style="zoom:50%;" />

<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/%E6%88%AA%E5%B1%8F2024-09-26%2016.14.08.png" alt="截屏2024-09-26 16.14.08" style="zoom:50%;" />                                                  

## 1.6 分组延迟，丢失和吞吐量



## 1.7 协议层次和服务模型



## 1.8 历史



## 1.9 小节

# pointsRecord

record some key points, maybe concepts, maybe process



网络用于不同进程间的通信，为了兼容不同设备，使用网络协议进行通信规范



## **Tcp/Ip网络模型** 

### **应用层** 

用户操作接触层面 - 工作在操作系统用户态

专注于为用户提供应用功能 - HTTP，FTP，Telnet，DNS，SMTP 

### **传输层** 

为应用层提供网络支持 TCP UDP 传输数据包

负责端到端的通信

#### TCP 

传输控制协议 **Transmission Control Protocol**

流量控制，超时重传，拥塞控制 - 保证数据包能可靠传输



 传输数据包大小超过**MSS**(TCP最大报文段长度)，将数据包分块 - TCP段(**TCP Segment**)

途中某个分块丢失或损坏，只需要重新发送这一个分块



#### UDP

用户数据报协议 **User Datagram Protocol**

**user** - 面向用户

**datagram** - 数据报 - 按报文(数据包)发送数据，不同于tcp建立连接，按字节流传输

只负责发送数据包，不保证数据包是否抵达，实时性高，传输效率高

UDP需要把TCP保证安全的特性在应用层上实现以达到可靠传输

#### 端口

端口用于区分同一台计算机中不同的网络应用程序



同一台计算机同时运行很多程序，他们要通过网络收发数据，端口用于标注自身，告诉操作系统数据分发给哪个程序



服务启动，创建一个进程，监听计算机中的某一个端口(要进行网络通信)，客户端向该端口发起网络连接或发送数据，就可以被这个进程收到



- 服务端对外提供服务，需要监听端口，端口通常是固定的，被动等待客户端连接
- 客户端使用临时端口(服务端响应目标)，动态分配的，主动发起连接 - 客户端的端口不是监听，而是使用操作系统临时分配的端口发起连接，因为监听端口，是等待目标端口的连接，客户端是主动发起一个连接，等待响应



### 网络层

网络环节错综复杂，负责网络包的封装分片，路由转发 - **IP协议** - 寻址路由



传输层报文作为数据部分，加上IP包头组装成IP报文，大小超过MTU(以太网一般为1500字节)再次分片



网络层数据包的路由转发通过IP地址定位

IPv4协议有32位

IP地址分为**网络号**(表示子网)和**主机号**(表示同一子网下的不同主机)

`10.100.122.0/24` 这是常见的ip形式

- 将ip地址和子网掩码与运算可以得到网络号
- ip地址和子网掩码取反后可以得到主机号

这是IP地址的寻址能力 - 通过网络号+主机号找到某个计算机的某个进程



另一个功能 - **路由**

网络中由网关，路由器，交换机等网络设备组成，网络路径错综复杂，在节点处通过路由算法确定目标路径

找到目标子网(通过网络号匹配)

### 网络接口层

将IP头部加上MAC头部，封装成数据帧

通过IP也就是网络层找到了目标子网，在子网中，需要使用以太网(局域网内设备的连接技术)的规则完成数据包传递

- MAC地址是设备网卡出厂编号，全局唯一
- MAC头部有接收方和发送方的MAC地址
- 使用ARP协议 根据IP找到其对应的MAC地址



ARP - Adress Resolution protocol

### 数据包形式

- 网络接口层 - 帧 frame
- 网络层 - 包 packet
- 传输层 - 段 segment
- 应用层 - 消息报文 message

可以统称为数据包

## 键入网址显示过程

### HTTP

首先解析URL



**URL的组成**

协议(https) + Web服务器(域名) + 数据资源路径名(若无自动请求默认文件 /index.html)



根据url中解析出来的web服务器信息和文件资源路径信息，将其封装为HTTP请求

请求报文(请求行，请求头，请求体)+响应报文(状态行，响应头，响应体) 

### **DNS**

查询服务器域名对应的IP地址



首先域名是有**层级关系**的，越靠右层级越高

以www.server.com为例

- www.server.com 为 server.com的子域名
- 最后省略一个"." -- www.server.com.  "."代表根域
- 域名的层级形成DNS服务器的层级



**DNS服务器层级**

- 根DNS服务器(".")  - 不记录网站详细ip，引导查询TLD服务器
- 顶级域DNS服务器 - TLD服务器，引导查询权威DNS服务器
- 权威DNS服务器，提供目标域名的IP地址(只有这一层有真正数据IP的记录，其他是路由功能)

**DNS执行流程**

对于xyz.login.mail.google.com 的解析

- 客户端发出DNS请求，将ip请求到本地DNS服务器(客户端TCP/IP设置项)
- 本地DNS服务器判断缓存是否命中，否则请求根DNS服务器(".")
- 根DNS服务器根据域名顶级内容返回对应TLD服务器("com.")，**本地DNS服务器再次请求**TLD服务器
- TLD服务器根据域名内容返回对应的权威DNS服务器(google.com.)，**本地DNS再次请求**
- 在权威DNS服务器(公司注册一个域名，子域名都可以用，只要分别配置DNS)中可以查询到域名对应ip(一个权威服务器应该维护自身所有*.google.com.的域名，维护这个域名下所有子域名的解析记录)



**从根到TLD到权威的原因，不能跨级查询，分层的原因**

- 减少根级DNS服务器的压力，全局维护，避免数据量太大，并发量太大
- 分层设计可以分摊请求压力
- 减轻某个域名变更在DNS服务器中的修改维护压力
- TLD服务器一般由各大国家或者组织维护，com net cn edu



**DNS缓存**

- 浏览器缓存 - 只在浏览器进程有效
- 操作系统缓存 - 操作系统统一缓存
- hosts文件 - 系统级静态的DNS表，绕过DNS的查询过程，直接绑定某些域名和ip
- 优先级为 hosts文件，浏览器缓存，操作系统缓存，本地DNS服务器



### 协议栈

此时完整了HTTP请求的封装，目标ip地址的解析，进入 网络协议中 传输网络层



操作系统中的协议栈是实现了网络通信协议的逻辑结构，一层层实现网络协议，实现数据网络传输的过程

每一层 层层封装解析(传输 - 网络 - 数据链路 段 - 包 - 帧) 类似栈的结构

协议栈在程序代码封装层面应用，其之后就是物理阶段的网卡信息传输



Socket - 网络通信接口，操作系统通过协议栈实现网络通信，但是应用程序无法直接操作，操作系统提供Socket API，调用api实现网络通信 - 服务端常见一个Socket，客户端也创建Socket去连接

所以Socket是应用层和传输层之间的编程接口，让程序可以访问底层的网络协议



协议栈根据网络协议实现，分为多个部分，上层部分依赖下层实现，应用程序通过调用Socket库委托协议栈工作



一般情况根据协议栈传输层的实现分为 TCP Socket 和 UDP Socket

### TCP

应用层数据(消息/报文 message) 加上TCP头 成为TCP段 - segment

**TCP报文头部格式**

- **源端口号和目标端口号**(各自16位) - 进程的相互定位
- **序号**(32位) - 包的序号 - 解决包乱序问题
- **确认序列**(32位) - 确认号，确认对方是否收到，否则重新发送，解决丢包问题
- **状态位** - TCP面向连接，维护双方连接的状态 **SYN**(发起连接)**ACK**(回复)**RST**(重新连接)**FIN**(结束连接)
- **窗口大小**(16位) - 声明窗口大小，标识自己的处理能力，做流量控制(还会做拥塞控制)
- 校验和 - 16   紧急指针 - 16



**三次握手**

TCP连接，在双方计算机维护一个状态机，在连接建立过程中，双方状态连续变化

三次握手的目的是保证双方都有发送和接受的能力

- 首先客户端和服务端都处于closed的状态，服务端监听某个端口，变成listen状态
- 客户端发起连接SYN，自身变成syn-sent状态(第一次)
- 服务端收到客户端SYN并返回ack，变成syn-rcvd状态，并向客户端返回一个SYN请求(第二次)
- 客户端收到服务端的SYN和ack返回对服务端的ack，并变成established状态(第三次)
- 服务端收到客户端的ack，也变成established状态



SYN请求会携带序列号，对于SYN的ack会携带确认序列号(SYN序列号+1)

```
客户端                     											服务端
 |                        											 |
 | --------- SYN(seq=x) -----------------------> |
 |                        											 |
 | <------ SYN+ACK(seq=y, ack=x+1) ------------- |
 |                        											 |
 | --------- ACK(ack=y+1) ---------------------> |
 |                        											 |
连接建立                    									连接建立
```

- 第一次握手，确保客户端可以发送，服务端可以接受
- 第二次握手，确保服务端可以发送，客户端可以接受
- 第三次握手，确保双方都能确认彼此能收发，最终确定连接建立



- 两次握手，服务端不知道客户端是否收到自己的回应，连接状态不对等
- 四次多余





在linux中使用 `netstat -napt`查看当前系统中所有的TCP网络连接情况(协议+原地址/端口+目标地址/端口+连接状态+进程PID和进程名称)



- message 超过MSS TCP分段 分别组装TCP头部
- segment + IP头部组成packet，packet超过MTU(网络包最大长度，以太网中位1500字节)分包



TCP段形成后，TCP头部为新内容，TCP段数据部分则为HTTP头部+数据

### IP

寻址路由

TCP段加上IP头封装成IP包



IP头信息

- **版本，长度，标志。。。**

- **源地址IP**(客户端输出IP地址) - 32

- **目标地址**(通过DNS域名解析得到的Web服务器IP) - 32

- **协议**  - 8 - 协议号的内容为传输层的协议代码 - 比如使用TCP传输则协议号为06(H)



**客户端多网卡的IP地址选择**

如果客户端存在多个网卡，需要判断使用哪一个网卡来发送包



首先在Linux系统中使用`route -n`来查看系统路由表(记录不同目标ip应该通过哪个网关，从哪个网卡出去)

路由表格式 - 目标ip-网关地址-子网掩码-..网卡名称

- 如果目标ip为 0.0.0.0代表这是兜底方案，任何不满足其他条例的目标ip都可以走这个

- 如果网关地址为0.0.0.0代表不用通过网关，通常就是目标ip和自身ip在同一个子网，直接使用mac地址通信，不用通过网关到公网
- 如果网关地址为一个具体ip，这通常为路由器地址，代表通过网关转发到公网



对于一个destination ip 每一条逐条判断

- 将目标ip和子网掩码与运算，去和destination 匹配，如果匹配成功，将这一条例的网卡的ip地址作为源地址
- 如果多条条例符合，优先使用掩码最长的那一条

### MAC

将IP包加上帧头帧尾封装成帧数据

**帧头**

- 接收方MAC地址 - 48(ARP协议)
- 发送方MAC地址 - 48(网卡生产的时候写入ROM，直接读取)
- 协议类型 - 16 - 0800(IP协议) 0806(ARP协议)



每一次MAC帧的封装都是一级一级的

跨网段的通信是由源地址 - 网关路由器 - N个中间路由 - 最终目标

每一次传输都会重新封装mac地址

所以第一次封装目标mac为gateway对应mac(通过路由表查询本次gateway)

所以说MAC 为两个设备之间的传输



ARP协议在以太网中以广播的形式，对以太网中所有的设备询问目标ip，某个设备ip符合就会返回其MAC地址

并且ARP有缓存实现，广播前先会查询缓存



**帧尾**

- FCS - Frame Check Sequence 帧校验序列，计算序列并作比对，判断数据是否在传输中损坏

(帧尾是在网卡传输阶段加上的)

### 网卡

网络包，数据包本质是二进制数据

网卡负责将数字信号转化为电信号，通过网线发送，这是数据真正发送的过程



网卡通过网卡驱动程序控制

网卡驱动程序获取网络包，将其父知道网卡缓冲区

- 在开头加上**报头和起始帧分界符** - 标记包起始位置
- 末尾加上帧尾

### 交换机

- 基于以太网 - 二层网络设备
- 交换机端口不具有MAC地址

- 工作在数据链路层
- 局域网内的通信中转站，负责根据MAC地址转发帧
- 每个端口可以连接一个设备
- 维护MAC地址表，记录哪个MAC在哪个端口



网卡的电信号首先传入交换机，交换机根据接收方MAC地址，判断转发目标(可能本地设备，可能转发到路由器)

- 交换机模块接受电信号，并转换为数字信号
- 通过帧尾的FCS做校验
- 校验通过后加入缓冲区
- 在MAC地址表中查询接收方MAC地址
- 根据查询结果将信号发送到对应端口

计算机网卡具有MAC地址，接受包的时候判断MAC地址是不是自己的，如果不是就丢弃



**MAC地址表中查询不到的结果**

- 可能目标MAC和其对应端口还没有被记录过
- 可能一段时间后记录被删除了
- 交换机会把包发送给除了源端口以外所有端口
- 有端口对应设备响应后，就会把这一条MAC - 端口对应数据加入表中



如果接收方MAC地址是一个广播地址，则直接广播给自身外的所有端口

- MAC地址 - FF:FF:FF:FF:FF:FF
- IP - 255.255.255.255

### 路由器

三层网络设备，基于IP设计，路由器各个端口都有MAC地址和IP地址

**基本流程**

接受数据包，通过路由表查询转发目标，将相应端口作为发送方将数据包发送出去



- 接受电信号，并转化为数字信号，帧尾FCS校验
- 检查数据包中的接受方MAC地址，判断是不是给自己的，否则丢弃
- 去掉MAC头部(MAC为两点传输，这一次头部已经完成了使命)
- 根据IP头中的目标IP在路由表中进行查询转发目标
- 如果路由数据行的gateway为空，代表已经到达目的地
- 如果不为空，重新封装MAC头部，继续转成电信号转发
- 到达目的地后，使用MAC缓存或者APR协议获得目标MAC
- 整个转发过程中，源IP和目标IP是不变的，变的就是MAC头部，每一次MAC头部的封装，完成两个节点之间的传递，直到到达目的地(发送MAC成了对方的路由器MAC，判断出来接受MAC在同一子网了)

### 数据处理

**服务器对数据包的处理**

- 首先查看MAC头部是否和服务器本身符合
- 查看IP头部中ip是否符合，并从IP头部查看传出层协议，比如是TCP
- 查看TCP头部，查看序列号，返回ACK，并从TCP头部中获取端口
- 将包发送给HTTP进程
- HTTP进程返回页面，封装在HTTP相应报文中，HTTP相应报文重新进行一次TCP IP MAC封装发送
- 客户端收到响应后，解析到数据，渲染html
- 最后客户端四次挥手，断开和服务端到连接

### 概括

<img src="https://typora---------image.oss-cn-beijing.aliyuncs.com/Screenshot%202025-07-13%20at%2022.35.00.png" alt="Screenshot 2025-07-13 at 22.35.00" style="zoom:50%;" />

## OSI网络模型

国际标准化组织制定的通信参考模型

- **应用层** - 给应用程序提供使用接口
- **表示层** - 负责数据格式转化，编码，加密解密，压缩操作
- **会话层** - 建立，管理，终止实体间的通信会话
- **传输层** - 端到端的数据传输
- **网络层** - 数据寻址，路由，转发， 分片
- **数据链路层** - 封装数据帧，利用FCS校验，MAC寻址
- **物理层** - 物理传输数据 - 电信号/无线传输

OSI七层模型是理论上的分层，没有具体的实现方案



TCP/IP网络模型是对OSI的抽象实现，并且简化了模型，Linux按照TCP/IP模型实现协议栈

## Linux网络协议栈

协议栈是对TCP/IP中传输层，网络层，网络接口层的具体实现，负责数据的封装，路由，分片

- 将应用程序发出的数据，一层层封装，最后和网卡交互发送
- 收到的数据在协议栈中一层层解析返回给应用程序
- 应用程序通过Socket库操作协议栈
- 协议栈可以和网卡完成对接

## Linux接收网络包

网卡接收网络包，使用DMA将网络包写入指定内存位置 - Ring Buffer(环形缓冲区) 并通知操作系统网络包到达



**网络包到达的通知**

如果直接在网络包到达的时候触发中断，CPU收到中断会暂停当前任务处理，在高性能网络常见下，频繁触发中断会影响系统效率



Linux内核2.6 引入**NAPI机制**

> **中断驱动触发 + 轮询处理**的混合模式，**避免高并发下频繁中断 CPU，提高包处理效率和系统吞吐量**

- 首先网卡收到第一个数据包，使用DMA把数据写入内存，触发**硬件中断**通知CPU
- CPU收到**硬件中断**请求后，会调用注册的中断请求函数
- 硬件中断函数中 - **屏蔽中断**(新数据包发送到网卡不再触发中断，仅写入内存) - **发起一个软中断**(CPU稍后处理)
- 内核调度软中断处理函数 - 轮询网卡缓冲区，读取数据包
- 轮询结束，恢复中断，允许下一次新数据包触发硬件中断



**软中断处理**

- 内核ksoftirqd线程专门处理软中断 - 其收到软中断后轮询处理线程
- ksoftriqd从Ring Buffer中获取数据帧(sk_buff表示)，操作网络协议栈逐层处理

**网络协议栈操作**‘

- 进入网络接口层 - 检查报文合法性FCS校验，确认是IPV4还是IPV6，去掉帧头帧尾，交给网络层
- 网络层，取出IP包，判断网络包走向，确定是TCP还是UDP，去掉IP头，交给传输层
- 传输层根据TCP或者UDP，取出头，根据ip+端口找到对应的Socket(正在监听或者通信的套接字)，把数据放到Socket的接收缓冲区
- 应用层调用Socket接口，将内核Socket接收缓冲区数据拷贝到应用层缓冲区，唤醒用户进程

## linux发送网络包

- 应用程序调用Socket发送数据包接口，从用户态转为内核态
- 内核申请一个内核态的sk_buff，将用户数据拷贝到sk_buff内存，加入发送缓冲区
- 网络协议栈从Socket发送缓冲区取出sk_buff，逐层处理
- TCP传输，会拷贝一个sk_buff副本(原来的sk_buff在网卡发送后会被释放删除，TCP为了支持重传，保存副本)
- 增加TCP头，message - segment 消息大于MSS分片
- 网络层，增加IP头，超过MTU分片
- 网络接口层封装帧头
- 触发软中断，告诉网卡驱动程序网络包需要发送
- 驱动程序从发送队列读取sk_buff，加入Ring Buffer(数据包指针)，将数据映射到网卡可访问的DMA区域
- 数据发送完成，网卡设备触发硬中断，释放sk_buff和RingBuffer内存
- TCP报文ACK应答，传输层释放sk_buffer





在协议栈层级传递数据的时候，不会发生数据拷贝

使用一个指针指向数据区域，移动指针增加或移除不同头部



**发送网络包的内存拷贝操作**

- 首先在协议栈中的数据包装不设计内存拷贝

- 数据映射到DMA区域为零拷贝，映射页表？不属于内存拷贝

- 应用程序调用的时候，内核将用户数据拷贝到内核态的sk_buff内存，加入发送缓冲区

- TCP协议下，sk_buff需要被拷贝一份副本用于错误重传

- IP层发现sk_buff大于MTU需要分片并拷贝

- TCP的分片不属于数据拷贝，可能对于message进行MSS的判断，创建多个sk_buff分别包装TCP头(?)

  



