

自己优化的点 - 双token登录，ai接口限流，缓存的删除

需要改进的点 - 图片的上传使用断点上传和分片上传 对于cos使用CDN优化

# 整体介绍

介绍一下项目（云图库），项目背景，包含哪些部分，完整的业务流程，使用的技术，数据怎么存储的

**项目背景**

在数字化发展的互联网背景下，图片的体量越来越大，我们难以在本地保存并高效检索大量图片，同时多方对图片的需求也越来越大，从个人到团队到企业，从日常交流到新兴的自媒体行业需求。这个项目产生的背景，就是为了应对图片多元使用管理的需求，提供高效稳定的方式来检索，存储，操作图片

体量+使用需求

**主要的模块**

- 用户模块 - 用户的增删改查，退出登录，登录
- 图片模块 - 分页检索，删除，修改，AI扩图，以图搜图，团队模式的多人协同编辑
- COS模块 - 图片的上传下载
- 空间和空间成员模块 - 主要是增删查改，还有vip空间的分表
- 鉴权模块 - 身份注解拦截鉴权，sa-token RBAC模型权限鉴权

**完整的业务流程**

- 所有用户可以在公开的平台上去上传和检索图片，根据图片的各种信息(名称，简介，分类，标签，体积，长宽，比例，格式)精确查找图片。
- 管理员可以操作任何图片(有权利增删改查) 可以对用户上传的图片进行审核
- 个人用户可以创建自己唯一的私人空间，作为云端图片存储，进行管理检索编辑，其他人除了管理员无法看见并修改
- 对于企业团队，可以创建团队空间，共同上传并管理图片，可以邀请成员加入，并且共享图片可以多人实时编辑

**使用的技术**

**SpringBoot Mysql MP Redis Caffine Jsoup HttpClient Sa-Token WebSocket Cos AI**

**数据存储**

- **picture**表 - **基本信息**(名称，url，简介，分类，标签，长宽高，格式，比例，主色调，创建修改时间) **审核信息**(审核状态，审核者ID，审核信息) **其他**(缩略图地址，所属空间id)
- **space**表 - **基本信息**(空间名称，级别(vip)，最大体积，最大图片数量，目前体积，目前数量，创建修改时间，是否删除标识，空间类型(个人/团队))
- **user**表-**基本信息**(账号密码，头像，简介，角色(admin)，修改创建时间)
- **space_user**表 - 空间id，用户id，修改创建时间

图片存储在腾讯COS对象存储服务，文件名和url关联

# 简历问题

## 第一



这是一个图片的管理平台，展示图片或者说用户搜索查找图片是最基本的功能与要求。

所以说图片分页检索功能是最常用的

接口细节 - 用户可以设定图片的细节来获取对应的图片分页结果，我们对这个结果进行了缓存优化，具体是将整个请求对象使用json工具转成json字符串，并使用md5工具生成md5哈希值(使得key长度统一，并减少长度，节省存储成本)并拼接一个prefix构成缓存的key，维护缓存(我自己做了缓存失效删除的功能拓展)

请求key的哈希冲突问题

- 首先可以尝试使用哈希空间更大，算法更优，碰撞概率更小的哈希算法(MD5 -> SHA-256)
- 我们在分页的结果包装类中增加一个部分关键请求参数的签名，将几个关键列参数+分页参数拼接成一个字符串，使用缓存的时候比对这个签名



设置随机过期时间，防止缓存雪崩

查询效率提升200%是使用两种方式测得的

- JMH 基准测试框架，相对静态的测试，经过10次预热后，排除jit的优化 
- 启动arthas，跟踪我的java进程pid，trace 类+接口 测试执行时间

## 第二

在用户调用接口准备创建用户空间的时候(个人空间 和 团队空间，都只能创建一个)为了防止由于网络抖动或者用户的反复提交而创建多个空间，每个用户尝试去创建空间的时候加锁，锁的对象是(用户id 转成字符串 intern后的结果) 每个用户的锁不同，锁的并发度大

这里为什么把它叫做分段锁 - 分段锁原意是将某一个数据结构划分成多个段，对每个段独立加锁，使得锁的竞争范围变小，提升并发性能，这里对其做语意的提升，我们不创建一个单独的锁对象，而是多方独立加锁，分成了多个段加锁，同样也是并发提高的目的

使用TranscationTemplate 在方法内部开启一个事物，保证用户空间的创建和空间关联数据的创建这些元信息的创建是一个整体(创建团队空间的时候，需要维护团队空间id和用户id的记录)，防止出现数据不一致的问题

## 第三

腾讯cos对象存储服务中存储了大量的数据，存储成本随之变高

我们选择在cos的存储桶管理中开启数据沉降功能 - 在对象存储中，把存储层级分为标准存储，低频访问存储，归档存储，深度归档存储

由前往后，存储成本变小，访问成本变大

cos支持高级的数据沉降(有些cos只支持根据对象创建的时间 比如 30天后降一级，60天后再降一级) - 可以根据对象的最后一次访问时间，根据对象的访问频率来决定对象的降级操作



虽然cos存储对象的可靠性理论上高达99.9%，但是为了防止由于种种原因，也为了完善系统的功能，开发了失效图片清理的接口

首先我们让COS监听图片删除事件，万一图片由于某种原因被删除了，将事件绑定到一个kafka，编写一个Kafka消费者逻辑，监听队列，收到消息后，将对应url的图片标识为已删除



使用Spring Task 设置一个定时任务，在夜间1点，业务低谷期

cos提供分页机制，nextMarker分批获取对象，多开几个线程，同时获取多个批次的对象任务

模仿redis的惰性删除

int targer = total / 10 随机访问targer条记录，使用httpClient模拟访问，查看网址失效情况

记录失效比例，如果比例大于10% 重新进行一次操作

## 第四

门面模式 - 子系统将多个复杂的接口整合为一个简单接口，方便主系统或者客户端的调用，而其无需关心子系统内部如何协调工作

以图搜图

这个功能的目的是通过调用百度搜图的api，返回一张图片相似图片的url list集合

其需要通过三次api的顺序调用，分别获取图片列表，解析元数据地址，提取url列表

两种 api 调用方式：

- Jsoup - 通过访问url 解析对应的html文件
- HttpClient - 是Apache HttpComponents 的一部分，用于通过post get等发送http请求，处理响应头，体

这是一个低级的api，使用它需要大量的配置信息，我们使用Hutool工具包中的HttpUtil和HttpRequest来调用api，方便快捷获取响应结果，其底层是对apache的httpClient的封装



第一步根据传入图片url，使用HttpRequest.post 添加url作为请求体，完善一些配置(请求体中描述)，获取响应体，通过Json工具将响应体解析成map，获取url键，获取到的值就是以图搜图结果的地址，这是一个图片页面



第二部通过Jsoup解析上述的url，解析html标签，使用正则表达式提取出firstUrl的内容，结果是一个url



第三部使用HttpUtil解析上述url，使用HttpUtil稍微轻量，简单一点，get请求，请求的响应体中包含以图搜图结果图的url列表，使用json工具解析成Java List对象返回



将上述操作封装成三个api调用过程，创建一个Facade类(外貌)，类中依次调用api，直接返回结果，避免在Service中直接编写这些与业务相关不大的代码，增加耦合度，现在以图搜图api层面的操作和service调用的操作耦合度降低，对api的改动更为方便，无需直接在业务逻辑service层面改动



# 注册用户 密码加密 加盐 

1. **创建 `Session` 时生成 `Session ID`**：当客户端第一次访问服务器，服务器调用 `request.getSession()`创建新的 `Session` 时，会为这个 `Session` 生成一个唯一的 `Session ID`。
2. **发送 `Session ID` 到客户端**：服务器会创建一个名为 `JSESSIONID` 的 `Cookie`，并将 `Session ID` 作为 `Cookie` 的值，然后通过 `response` 对象将这个 `Cookie` 发送给客户端。示例代码如下：
3. **客户端携带 `Cookie` 访问服务器**：客户端收到 `Cookie` 后，会在后续的每个请求中自动携带这个 `Cookie`发送给服务器。
4. **服务器根据 `Cookie` 关联 `Session`**：服务器在接收到客户端请求时，会从请求中提取 `JSESSIONID` 的 `Cookie` 值，然后根据这个 `Session ID` 找到对应的 `Session` 对象，从而识别出是哪个用户的请求。示例代码如下：

json 工具的 会员兑换码 兑换功能



缓存key的name构建

分页图片请求的缓存

先对请求参数(很多很多条件)使用**JSONUtil.toJsonStr**转成json字符串，在使用MD5算法加密，成为一个key，虽然md5可能会有冲突，但是问题不大，这样子相同的请求多次访问，可以直接返回缓存(caffine固定时间，redis随机时间)



缓存一致性 - 图片数据发生变更，发送图片id到kafka，kafka编写一个消费逻辑

我们维护了一个表<id , List<Key>> 消费逻辑去遍历这个表

或者全部删除

# CDN节点

Content Delivery Network 内容分发网络 

在腾讯云的CDN页面对我们的bucket进行加速

- 通过将内容缓存到离用户更近的节点，用户请求内容时可以从最近的服务器获得，减少了访问延迟。
- CDN缓存静态内容，减轻源服务器的负载，从而提高系统的稳定性和可扩展性。
- 如果某个节点出现问题，CDN会自动切换到其他节点，保证内容持续可用。



在CDN配置需要加速的域名

用户访问使用CDN的网站，首先导向到DNS服务器，DNS根据用户地理位置和网络状况，将请求导向最近的CDN节点，如果节点中缓存命中，直接返回，若没命中，CDN从源站访问并换缓存返回

# 动态分片

这是一个vip功能，对于团队的图片空间，一个团队的图片可能数量非常大，也可能很分散，在数据库中根据spaceID进行比对获取的速度和效率可能非常慢，如果一个团队开启了VIP功能，我们将空间的类型设置为vip

并动态为其分出表来，为什么要用分片技术，因为希望保证对图片的各类操作是无感的

shardingJDBC 是 aop操作，解析并改写sql，根据分片规则使之路由到正确的表或者库

这里使用ShardingSphere(类似于mycat的中间键，实现无感的分片操作)

先说一下**分片的基本流程**

我们主要维护**分片节点列表**和**分片算法**

对于一条sql，分片中间键首先解析sql，根据我们的分片算法提取分片键，确定将请求转发到分片节点列表中的哪一个节点上去

首先在yml配置文件中**配置ShardingSphere**

- mysql的地址
- 目标分片表名
- 分片表的集合，**actual-data-nodes**也就是实际存放数据表的集合，**没有直接指定**，因为要实现动态分片
- 分片列名(spaceID)
- 指定分片算法类型是class_based **基于表的**，
- **自定义分片算法的 类名**

自定义分片算法 - PictureShardingAlgorithm 实现StandardShardingAlgorithm接口的标准分片配置文件

主要实现**doSharding**操作(传入目前**已经存在的分片表名集合**，还有一个分片参数(分片列名，分片值，原始逻辑表名)) 方法的目的，是根据分片参数，抉择出一条数据行应该存在于哪个表(return 的表名，就是他要去的位置)

- 如果是 spaceID = null --- 这个图片不属于空间的，属于公共的，返回原始逻辑表名
- 根据规则构建代理列名 - picture_+spaceID 如果这个代理列名存在于集合中，返回这个列名，不然就是返回原始默认列名



上述的是**分片路由**选择的重写

动态分片的重写需要手动实现 ： 

创建一个用于动态分片管理的Bean

获取分片表名集合 - 构建方法 - 使用space的service方法， 获取space类型为vip的所有数据行，一一解析其id，根据分片列名的构建规则，将其转成一个列名集合



更新 ShardingSphere 的 **actual-data-nodes** 动态表名配置

- 将动态表名用工具类转成一个String，用，分隔

- 获取ContextManager ShardingSphere上下文管理类
- 从管理类中获取分片的所有元信息
- 从所有元信息中提取分片规则的元信息
- 将那条元信息的actual-data-nodes变更为最新的
- 将配置信息跟新到ContextManager
- contextManager reloadDatabase



当我们新创建一个vip的团队空间的时候，调用跟新方法， 根据团队id，用MP的SqlRunner执行一条建表语句，然后调用上述的actual-data-nodes刷新方法，完成动态分表



# WebSocket + Disruptor

**功能概述**

对于一张团队空间所属的图片，有编辑权利的团队成员可以进行编辑，同一时间只有一个成员可以进行编辑操作，其他操作此图片的成员只能实时看到修改过程

**流程概述**

客户端尝试和服务端建立WebSocket连接，发送编辑请求(**消息类型** - 进入编辑，执行编辑，结束编辑 **编辑动作** - 放大 缩小 左右旋转 )

服务端尝试解析请求，并负责响应(此动作的发起者 消息类型 编辑动作 以及详细描述message)转发的工作，发送给所有和此图片建立连接的websocket用户，让其可以根据响应得知图片修改的具体形式

**拦截器**

我们实现一个**HandshakeInterceptor**的实现类 (在握手阶段进行拦截处理)

重写**beforeHandShake**方法，在握手开始的时候，Http请求转换为WebSocket连接之前调用执行(基于http协议发起websocket请求尝试升级协议)

我们验证请求携带的参数是否合法判断是否连接，防止在高并发环境下，先建立连接后发现参数不合法，浪费连接性能

比如检查图片是否携带，图片是否合法，用户是否登录，以及用户是否又权利操作图片，如果不满足条件，直接拒绝握手

**具体实现**

项目的规划是，团队成员在进行协同编辑的时候，先选择想要操作的图片，这一步客户端和服务端建立webSocket连接

进入操作页面之后，可以选择进入编辑，这一步存在竞争，可能会竞争失败，因为同一时间只能有一个用户处于竞争状态

成功获取到编辑权利后，可以自由编辑，其他成员会被服务器发送编辑内容，然后可以选择结束编辑，释放编辑锁，其他用户此时就可以尝试进入编辑了

我们实现TextWebSocketHandler的实现类，这是Java WebSocket编程中的一个核心抽象类，用于处理webSocket消息

我们程序中主要重写了连接生命周期管理的方法，分别在webSocket连接建立前和断开后进行逻辑描述

建立完连接：维护一个map，key是图片id，value是WebSocketSession集合，代表和这个图片建立操作的用户集合，建立完连接，应该先加入这个图片所属的webSocketSession集合，并且向其他用户发送 XXX进入操作的通知

连接断开后：在WebSocketSession集合中移除用户，向其他用户发送操作退出的通知



其余就是三个动作 - 进入编辑，执行编辑，退出编辑



进入编辑 - 维护一个map，key为图片id，value为用户id，进入编辑的前提是这个map中不存在要操作的图片id的key，代表此时还没有人正在编辑这个图片，此时向map中写入这个键值对，代表或得到了编辑权限，并将这个事件通知给其他webSocketSession集合中的用户

执行编辑 - 判断编辑操作的合法性(能否在自定义的操作枚举类中找到) 通知其他用户

退出编辑 - 释放编辑锁，通知 释放编辑权利 事件

**事件驱动**

在高并发环境下，对于所有websocket连接的建立，对于请求类型的判断，如果同步进行，并发量低，延迟高

我们解偶请求解析和响应转发的流程

webSocket连接发送请求后，重写TextWebSocketHandler中的handleTextMessage方法，处理消息，将其封装为Disruptor消息队列中的一个事件(请求内容，所属webSocketSession等)

编写消费者逻辑

解析事件，获取请求内容，根据操作类型(进入编辑，执行编辑，退出编辑) 完善方法参数，执行编写好的不同情况的消费逻辑

**Disruptor**

高性能无锁环形队列







为什么使用Disruptor呢

Disruptor

生产者将同一类型的事件加入到环形缓冲区(阻塞操作获取到缓冲区中下一个应该存放的位置，没有线程安全问题)

消费者配置好消费的事件类型，消费同一类型的事件

环形缓冲区 - 存放等待时间的位置，将数据存储在一个固定长度的缓冲区()，每个单位大小相同，并且首位相连，每次添加不用出队入队，只需要根据算法获取下一个应该存放的位置，仅仅通过指针的移动就可以完成，简单高效(读指针，写指针)减少缓存行失效，优化内存访问效率

如果写指针要超过了读指针，可能出现数据安全问题

- 阻塞机制，阻塞生产者，等待消费者消费
- 覆盖最老数据
- 指针同步机制，为事件维护序列号，通过序列号去检查事件，追踪其完成情况只有当事件被处理了才会覆盖

多消费者并发消费，维护事件序列号，当发现某个事物序列号不符合要求(比自己维护的表示小)代表顺序出错，不会消费，每个消费者维护自己的消费标识，彼此之间没有同步加锁的需求，性能高



优雅停机 - 当我们中断服务时，可能有些任务已经被提交到Disruptor中去了，避免这些已经提交的数据丢失，我们在事件处理Bean中定义一个@PreDestory方法，内部描述 队列shutdown，拒绝新任务添加，执行完成当前任务，Spring的DefaultSingletonBeanResgistry中维护了需要进行结束方法的bean集合，调用结束方法在容器关闭的时候



握手拦截器 - 

WebSocket 基于 **HTTP 协议**，但它会在请求建立阶段通过 HTTP  来启动。握手过程中，客户端和服务器通过 **HTTP 请求和响应** 交换特定的头部信息，以便升级协议并建立 WebSocket 连接。

创建一个HandShakeInterceptor，在握手之前 进行数据的校验（是否携带图片，是否有用户信息也就是用户是否登录，以及用户有没有编辑照片的权利）否则拒绝握手

防止建立连接后才发想不符合连接要求，浪费连接性能消耗



WebSocket的连接建立过程

客户端使用HTTP协议发起一个WebSocket握手请求(包含特定的WebSocket头部信息告知服务器准备升级协议，其中有Sec-Websocket-Key 客户端随机生成一个随机值，)

服务器收到客户端的请求，判断是否支持WebSocket协议并判断是否可以连接，如果可以，返回标识WebSocket协议升级成功的状态码101(响应头中会包含根据请求头中Sec-WebSocket-Key根据统一规则加密得到的一个响应值Sec-WebSocket-Accept)

客户端收到响应，判断响应回来的Sec-WebSocket-Accept和预想的是否相同，如是，则确定连接建立

那个随机值用来防治请求伪造 确保链接的安全性 服务端密钥GUID和。。。key使用Base64编码共同创造出accept

**请求头**

- 请求路径以及Http协议版本
- 目标主机
- 客户端要求将连接协议升级为 WebSocket。
- 要求服务器升级协议。
- Sec-Websocket-Key
- WebSocket协议版本
- Origin 请求来源，防止CSRF

**响应头**

- 同意升级协议的标识
- 告知客户端协议已经升级为WebSocket协议
- 服务器同意协议升级
- Sec-WebSocket-Accept



后续通信，传输帧数据，包含

**起始字节**：

- 表示数据帧的类型，常见的是文本帧和二进制帧。

**长度字段**：

- 表示数据的长度，可以是固定长度或者变长（取决于数据的大小）。

**数据**：

- 实际的数据部分，可能是文本或二进制数据。

**结束标志**：

- 数据帧的结束符。



# 使用Http实现WebSocket相同功能

为什么这么做的目的 - http更常用，客户端服务端同时支持websocket才能使用

**方案一** - 短轮询

客户端定时向服务器发送http请求，请求拉去数据

服务端收到请求，查看是否有新数据，有的话放入response中返回

前端根据response展示结果

- 可以模拟双向通信
- 无论有没有数据都要请求，浪费网络资源，数据至少有1s延迟跟新

**方案二** - 长轮询

客户端向服务端请求，服务端收到请求，不立即响应，讲请求挂起，监控是否有新数据产生

当服务端检测到新数据，把数据封装成响应，返回给客户端

客户端收到响应，展示数据，并马上再发起一个长连接

- 保证每次响应都是有结果的
- 每次数据传输后还是要重新发起一次连接，并且服务器需要同时维护很多挂起的请求，消耗性能



传统的MVC架构中，一个请求会占用一个服务器线程直到响应返回，对于这个长轮询，如果对于每一次请求都使用同步阻塞，连接将被耗尽

我们可以使用Spring提供的一种异步处理机制叫做DeferredResult

deferred为延迟，将请求返回类型封装成deferredReduslt的泛型，这可以允许服务器立即释放请求线程，直到数据准备好了，填装进deferredResult，返回，达到把相应延迟到未来某一刻的作用

可以为每一个defrredResult分配一个消息队列，消息队列去阻塞获取数据，获取成功就填装进deferredResult，写数据就写入消息队列

也可以直接维护deferredResult的队列，直接往某个实例写入数据

**方案三** - 

服务端向客户端建立一条单向数据通道，主动发送数据

基于selvet的异步处理特性和管道流机制

允许服务器接受请求不关闭连接，而释放主线程资源，建立一条持续的数据流通道

- 持续发送数据
- 客户端无法向服务端发送

**方案四** - 基于TCP实现双向通信

TCP套接字基于TCP传输控制协议的网络编程接口，面向连接，允许连接双方双向通信

基本的流程就是

服务端建立TCP套接字并绑定到指定地址和端口，监听客户端连接请求

客户端建立TCP套接字并根据地址端口连接服务器 创建一个接受线程持续监听服务端消息，创建一个发送线程等待用户输入并传输到后端



后端循环接受新的客户端连接，为每个新连接创建专用的线程，并且维护到一个集合，收到客户端消息后，通过集合轮询发送给其他客户端

# WebSocket原理

WebSocket是基于Http的全双工协议

- 全双工通信 双向通信
- 持久连接 一次握手长久连接
- 可以传输文本或者二进制文件
- 轻量级协议

握手完成后，协议升级为WebSocket协议使用帧格式进行通信



服务端和客户端使用Ping/Pong进行心跳检测

一方要断开连接，发送关闭帧，包含状态码和具体信息

另一方收到关闭帧后也会返回自己的关闭帧

双方各自关闭TCP连接

应用层协议





# 身份以及行为权限认证

**基于RBAC模型** - **Role-Based**- Access Control 解偶

- User - 用户
- Role - 用户可以有多个角色 一组权限的集合
- Permission - 权限

使用sa-token框架实现RBAC模型，其可以通过注解(@SaSpaceCheckPermission)快速完成权限判断 - 维护好权限列表，注解中加上我们需要限制的权限，其底层默认调用getPermissioinList(手动实现配置接口，重写这个方法) 参数包含在用户登录的时候在权限认证框架中注册的用户ID(同时可以创建一个session存对象，根据这个id获取)，根据这个获取其权限列表，查看是否存在目标权限



对于RBAC模型，理论来说判断权限的过程，就是将用户进行角色的分配，只需要查看用户的所有角色中是否包含指定权限，但是在我们这个具体业务逻辑中，不能直接给用户分配角色，我们这里声明的角色比如观察者，编辑者是针对图片来设计的，因为同一个用户对于不同类型的图片(公共空间，私有空间，团队空间)角色是不一样的，所以每次需要做详细的逻辑判断，也正是因为无法完全确定用户的角色，对于用户身份(非权限)的判断，没有使用这个框架，而是手写了一个注解



在全局中，判断用户的身份是管理员还是非管理员

自定义@AuthCheck注解，注解内容为用户角色的枚举类

使用aop实现对注解的拦截增强，判断当前登录角色(根据id获取user对象中包含身份信息) 和 目标用户身份是否一样



然后就是权限判断的过程

权限是对图片而言比如查看，修改，删除还有空间成员管理

角色大致包括 

观察者 - 查看图片 - 普通用户对于公共图片 团队中的成员被分配了观察权限

编辑者 - 对图片增删改查 - 管理员 或者 个人对于自己的个人空间 或者团队中被分配了编辑权利的成员

管理者 - 管理员权限



权限认证的思路 - 根据当前用户 和 其要操作的具体模块信息 判断其身份并返回这个身份的权限列表



当前用户可以直接根据上下文获得

具体操作的模块信息，我们是根据解析请求数据来获取的，首先肯定可以从路径参数或者请求体中获得到id，不管是对什么对象(图片，空间) 做什么操作(增删改查)肯定都是会有这个id参数的，只是不确定这个id参数的含义是什么(表示图片或者表示空间或者表示空间成员)

然后我们解析请求路径，解析其中的关键字 - picture space spaceUser判断出这个id的具体含义



到这一步我们就知道了这一次请求的请求主体和其目标，进行进一步的逻辑判断

对所有情况进行枚举

- user为管理员，直接返回管理员权限
- 是对空间的操作，判断是否为私人空间(判断是否为本人或者管理员) 团队空间 (根据用户id 在spaceuser表中查到其权限返回)
- 对图片的操作，判断是否为公共图片(返回观察权限) 是否为私人图片(判断为本人或者管理员) 



sa-token框架在这个项目中的作用

- 使用注解完成高效的判断
- sa-token框架提供 上下文存储用户id，并可以根据这个用户id创建其个人session(可以存储键值对对象)
- sa-token同样的也可以判断身份(获取用户的身份列表判断) - 本项目没有实现

# ai接口调用

在 对图片的操作的中有一个功能是 使用ai完成对图片的一些操作和拓展

首先在阿里云中开启一个AI处理图片的接口服务，会获得一个apiKey

我们会通过将apiKey加入到ai接口的请求头Authorization中，达到一个身份判断的目的



在扩图接口中，Request中封装图片url地址，图片使用模型(固定好了，image-out-painting)

图片处理参数 - 旋转角度，水平垂直拓展比例，在图片的上下左右添加像素(这些参数被封装在Parameters中，每个参数使用注解规范好序列化和反序列化时的数据名字映射)

使用HttpRequest.post发送请求，维护好目标地址，填充请求头(apiKey)请求体(将请求参数序列化成json)

返回信息封装在结果对象(任务id，任务状态，接口错误码和信息，请求唯一id)



还有一个是根据任务id查询其执行进度，get请求，header中封装apiKey，将任务id参数拼接到url之后，结果包含这个任务的完整执行结果，包含总体任务的统计信息(总任务，成功任务，失败任务)





由于ai接口有免费额度，或者付费调用费用高

我们对于这个接口进行ip请求限流

令牌桶算法

系统以固定的速率生成令牌放入桶中，请求需要从桶中获取令牌才能被处理。只要桶中有令牌，请求就能立即得到处理

对每一个ip生成一个Hash结构(第一个键值对是上次访问的时间，第二个键值对是当前此ip剩余的令牌数量)

每次请求，获取curTime - preTime * 令牌生成速度(curTime - preTime默认为0)

这个结果是过去的时间段里面生成的令牌数量，如果这个数量+原有数量 > 1 则代表可以获取令牌，令牌数量-1并跟新时间

并为这个Hash结构设置一个默认的过期时间



# 图片的上传下载

我们使用腾讯的COS对象存储服务

自定义cos客户端配置类(CosClientConfig) 内部自动注入配置文件中的cos服务的配置信息，域名，密钥，桶名字

并使用这些信息初始化一个cos客户端(CosClient)用于图片的上传下载

最简单的使用，也就是简单的文件上传下载，对文件指定一个key，通过key实现上传，和获取

在此基础上我们封装了一个高级的上传方式 - 为上传请求添加更加具体的操作规则 - 我们首先指定好一个压缩规则(转换成webp格式降低图片大小，节省带宽(数据万象功能)提升加载速度) - 当图片内存大于一定值，配置压缩图规则，指定其路径等相关配置，并把压缩图规则添加到压缩规则中去，并将压缩规则添加到上传请求中，完成高级的上传方式(数据万象功能)



关于图片上传，我们有本地文件Fire上传和图片url地址上传两种方式，构造一个模版类PictureUploadTemplate(Object inputSource , String prefix)内部实现图片上传的基本流程(抽象类)

首先**校验图片的有效性**

**根据图片的文件名**获取后缀名并随机生成一个字符串，手动拼接文件上传路径(文件前缀(方法参数) + 时间戳 + 随机字符串 + 文件后缀名)

创建临时文件 将输入源写入临时文件 上传这个**临时文件**

- (临时文件位于磁盘，避免大文件在内存中直接处理，防止内存溢出)
- 对于磁盘中的临时文件，可以方便实现分片上传和断点续传
- 可以异步执行后续操作，直接返回给用户结果
- 上传失败可以基于临时文件重试，而无需用户重新提交表单



调用CosManager(封装CosClient 上传 下载方法的管理类)的方法实现文件的上传(key为伤处上传路径)

判断返回结果是否存在缩略图，封装结果返回(结果包含地址，名称，大小，宽高，宽高比，格式，主色调等)

图片可以重复上传(中途报错情况)，在finally逻辑中书写删除file临时文件的功能





我们有FilePictureUpload和UrlPictureUpload两种实现类

实现三个方法

- 校验图片有效性
- 根据输入的Object inputSource 提取出文件的文件名
- 加载文件内容到临时文件

FilePictureUpload - (验证文件体积，验证文件后缀名合法)(将Object强转为MultipartFile 直接通过类方法获取文件名)(还是使用MultipartFile方法将文件内容直接写入临时文件)



UrlPictureUpload - (尝试使用这个object创建URL对象，创建失败说明url格式有问题，验证url协议http(s) ,模拟一个请求判断图片是否存在，并验证其格式和大小)(使用hutool包的FileUtil获取其文件名)(使用hutool包的HttpUtil将其通过url下载到指定文件)





(模版方式)我有file和url两个上传文件的接口，但是他们共用一个service实现，在进行完一些基本的判断后，请求的数据格式，空间内存的判断，新增权限的判断等等，使用类似策略模式的方式，根据传入的object的类型(String - url,File - file) 判断使用PictureUploadTemplate的哪种实现





文件下载 - 

根据文件地址，使用cosManager获取图片res转换成字节流设置相应头的格式为二进制文件，并表示编码方式utf-8，并设置相应头支持下载，并添加文件name

最后将文件的二进制流写入Http的响应输出流中完成操作











# COS可能存在的问题

API密钥 - secretKey + accessKey

accessKey - 账户身份认证

secretKey - 与AccessKey配对的密钥，生成请求的签名(与请求头之类的一起计算出来一个标识 用户数据传输的一致性校验)，保证数据安全性

- 如果 COS 存储桶或对象没有正确配置权限，可能导致数据泄露。访问控制列表，允许授权用户访问，将桶设置为私有读写
- 非授权访问，API密钥或者AccessKey泄漏，未授权用户访问，定期更换Api密钥和AccessKey，多重身份认证
- 由于COS服务无法监听图片失效，只能监听增删改，我们手写一个内存清理的功能
- 由于硬件，网络等因素数据丢失，数据备份，版本控制
- **DDOS**(大量的无意义请求或恶意流量消耗COS资源)分布式拒绝服务攻击开启DDOS防护，监控异常流量及时限流响应恶意攻击(CDN加速，将恶意请求分散到不同节点，避免对COS主服务造成影响)
- 攻击者篡改COS数据，开始数据完整性校验，使用哈希算法MD5校验数据完整性



# 项目面试可能存在的问题

1. 介绍一下项目（云图库），项目背景，包含哪些部分，完整的业务流程，使用的技术，数据怎么存储的
2. 鉴权是怎么做的
3. 怎么确认用户的身份（session），session存的是啥，sessionid是什么格式，怎么生成的，
4. cos有哪些安全问题，怎么保证安全，
5. 共有读写还是私有读写，共有读私有写与私有读写有什么区别
6. websocket建立连接的过程，具体分为哪几步，websocket的头是什么样子
7. redis在项目中是用来干啥的，key是什么
8. 查询的条件有哪些，查询的流程是怎么样的，数据库查询出来数据的是什么格式，
9. 有没有做过压力测评，有多少QPS
10. 项目的挑战点（团队空间，鉴权，协同编辑）
11. 协同编辑的流程，怎么做到多人协作的（编辑锁）
12. 如果需要多人编辑的话应该怎么做，如在线文档
13. 如果重新做这个项目有哪些可以优化的点
